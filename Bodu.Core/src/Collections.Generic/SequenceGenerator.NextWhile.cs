// // ---------------------------------------------------------------------------------------------------------------
// // <copyright file="SequenceGenerator.NextWhile.cs" company="PlaceholderCompany">
// //     Copyright (c) PlaceholderCompany. All rights reserved.
// // </copyright>
// // ---------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;

namespace Bodu.Collections.Generic
{
	public static partial class SequenceGenerator
	{
		private struct State<T>
		{
			public int Index;
			public T Value;
		}

		/// <summary>
		/// Generates a sequence by repeatedly transforming a value while a condition remains true.
		/// </summary>
		/// <typeparam name="TResult">The type of elements in the generated sequence.</typeparam>
		/// <param name="initialValue">The starting value of the sequence.</param>
		/// <param name="conditionHandler">A function that determines whether the sequence should continue, based on the current value.</param>
		/// <param name="resultSelector">A function that computes the next value in the sequence from the current value.</param>
		/// <returns>An enumerable sequence generated by applying the transformation while the condition is met.</returns>
		/// <exception cref="ArgumentNullException">
		/// Thrown if <paramref name="conditionHandler" /> or <paramref name="resultSelector" /> is <see langword="null" />.
		/// </exception>
		/// <remarks>
		/// This method yields a lazy sequence where the next value is generated by applying <paramref name="resultSelector" /> to the
		/// current one, provided that <paramref name="conditionHandler" /> evaluates to true.
		/// </remarks>
		public static IEnumerable<TResult> NextWhile<TResult>(
			TResult initialValue,
			Func<TResult, bool> conditionHandler,
			Func<TResult, TResult> resultSelector)
		{
			ThrowHelper.ThrowIfNull(conditionHandler);
			ThrowHelper.ThrowIfNull(resultSelector);

			return NextWhile(
				new State<TResult> { Value = initialValue },
				state => conditionHandler(state.Value),
				state =>
				{
					state.Value = resultSelector(state.Value);
					return state;
				},
				state => state.Value);
		}

		/// <summary>
		/// Generates a sequence by repeatedly transforming a value while a condition remains true, providing the current index to each transformation.
		/// </summary>
		/// <typeparam name="TResult">The type of elements in the generated sequence.</typeparam>
		/// <param name="initialValue">The initial value of the sequence.</param>
		/// <param name="conditionHandler">A function that determines whether the sequence should continue based on the current value.</param>
		/// <param name="resultSelector">
		/// A function that computes the next value based on the current value and its zero-based index in the sequence.
		/// </param>
		/// <returns>An enumerable sequence generated by applying the transformation while the condition is met.</returns>
		/// <exception cref="ArgumentNullException">
		/// Thrown if <paramref name="conditionHandler" /> or <paramref name="resultSelector" /> is <see langword="null" />.
		/// </exception>
		/// <remarks>This overload allows the transformation to depend on the iteration index.</remarks>
		public static IEnumerable<TResult> NextWhile<TResult>(
			TResult initialValue,
			Func<TResult, bool> conditionHandler,
			Func<TResult, int, TResult> resultSelector)
		{
			ThrowHelper.ThrowIfNull(conditionHandler);
			ThrowHelper.ThrowIfNull(resultSelector);

			return NextWhile(
				new State<TResult> { Value = initialValue },
				state => conditionHandler(state.Value),
				state =>
				{
					state.Value = resultSelector(state.Value, state.Index++);
					return state;
				},
				state => state.Value);
		}

		/// <summary>
		/// Generates a sequence by transforming a custom state object while a condition remains true.
		/// </summary>
		/// <typeparam name="TState">The type of the internal state object.</typeparam>
		/// <typeparam name="TResult">The type of the elements in the generated sequence.</typeparam>
		/// <param name="initialState">The initial state used to generate the sequence.</param>
		/// <param name="conditionHandler">A predicate that determines whether the sequence should continue based on the current state.</param>
		/// <param name="iterateFunction">A function that computes the next state from the current state.</param>
		/// <param name="resultSelector">A function that projects the current state into a sequence value.</param>
		/// <returns>An enumerable sequence generated by iterating the state transformation while the condition is met.</returns>
		/// <exception cref="ArgumentNullException">
		/// Thrown if <paramref name="conditionHandler" />, <paramref name="iterateFunction" />, or <paramref name="resultSelector" /> is <see langword="null" />.
		/// </exception>
		/// <remarks>
		/// Use this overload to generate sequences where multiple values must be tracked (e.g., multiple counters, accumulators, etc.).
		/// </remarks>
		public static IEnumerable<TResult> NextWhile<TState, TResult>(
			TState initialState,
			Func<TState, bool> conditionHandler,
			Func<TState, TState> iterateFunction,
			Func<TState, TResult> resultSelector)
		{
			ThrowHelper.ThrowIfNull(conditionHandler);
			ThrowHelper.ThrowIfNull(iterateFunction);
			ThrowHelper.ThrowIfNull(resultSelector);

			IEnumerable<TResult> Iterator()
			{
				for (TState state = initialState; conditionHandler(state); state = iterateFunction(state))
				{
					yield return resultSelector(state);
				}
			}

			return Iterator();
		}
	}
}