// ---------------------------------------------------------------------------------------------------------------
// <auto-generated />
// ---------------------------------------------------------------------------------------------------------------

using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Bodu.Extensions;
using System.Globalization;

namespace Bodu.Extensions
{
	public partial class DateTimeExtensionsTests
	{

		[DataTestMethod]
		[DataRow("2024-01-01", 1, 0, 0, "2025-01-01")]                                      // +1 year
		[DataRow("2024-01-01", 0, 1, 0, "2024-02-01")]                                      // +1 month
		[DataRow("2024-01-01", 0, 0, 1, "2024-01-02")]                                      // +1 day
		[DataRow("2024-01-01", -1, 0, 0, "2023-01-01")]                                     // -1 year
		[DataRow("2024-01-01", 0, -1, 0, "2023-12-01")]                                     // -1 month
		[DataRow("2024-01-01", 0, 0, -1, "2023-12-31")]                                     // -1 day
		[DataRow("2024-01-31", 0, 1, 0, "2024-02-29")]										// Month overflow (leap year)
		[DataRow("2023-01-31", 0, 1, 0, "2023-02-28")]										// Month overflow (non-leap)
		[DataRow("2024-02-29", 1, 0, 0, "2025-02-28")]										// Leap year day add 1 year
		[DataRow("2025-05-01", -1, -2, -1, "2024-02-29")]									// Subtraction
		[DataRow("2024-01-01", 0, 0, 1.5, "2024-01-02T12:00:00")]							// Half-day
		[DataRow("2024-01-01", 0, 0, 0.25, "2024-01-01T06:00:00")]							// 6 hours
		[DataRow("0001-01-01", 0, 0, 0, "0001-01-01")]										// Lower bound
		[DataRow("9999-12-31", 0, 0, 0, "9999-12-31")]										// Upper bound
		[DataRow("2024-01-01T00:00:00", 0, 0, 1.0 / 86400000.0, "2024-01-01T00:00:00.001")] // Exact +1 ms
		[DataRow("2024-01-01T00:00:00", 0, 0, 1.0 / 86400000, "2024-01-01T00:00:00.001")]	// Precise tick result
		public void Add_WhenValuesProvided_ShouldAddProperly(string inputDate, int years, int months, double days, string expectedStr)
		{
			DateTime input = DateTime.Parse(inputDate);
			DateTime expected = DateTime.Parse(expectedStr);
			DateTime actual = input.Add(years, months, days);

			Assert.AreEqual(expected, actual);
		}

		[TestMethod]
		public void Add_WhenResultExceedsMaxDateTime_ShouldThrowExactly()
		{
			DateTime nearMax = DateTime.MaxValue.AddDays(-1);

			Assert.ThrowsExactly<ArgumentOutOfRangeException>(() =>
			{
				DateTime result = nearMax.Add(0, 0, 2); // Should exceed DateTime.MaxValue
			});
		}

		[DataTestMethod]
		[DataRow("2024-03-10T01:30:00", 0, 0, 1.0 / 24, "2024-03-10T03:30:00", "Pacific Standard Time")]
		[DataRow("2024-11-03T01:30:00", 0, 0, 1.0, "2024-11-04T01:30:00", "Pacific Standard Time")]
		public void Add_WhenInDstTransitionZone_ShouldRespectTimezone(string inputDate, int years, int months, double days, string expectedDate, string timeZoneId)
		{
			var tz = TimeZoneInfo.FindSystemTimeZoneById(timeZoneId);
			DateTime input = DateTime.Parse(inputDate, null, DateTimeStyles.AssumeLocal);
			var unspecified = DateTime.SpecifyKind(input, DateTimeKind.Unspecified);
			var expected = DateTime.Parse(expectedDate);

			// Convert to UTC, apply addition, then return to local
			var utc = TimeZoneInfo.ConvertTimeToUtc(unspecified, tz);
			var resultUtc = utc.AddYears(years).AddMonths(months).AddDays(days);
			var resultLocal = TimeZoneInfo.ConvertTimeFromUtc(resultUtc, tz);

			Assert.AreEqual(expected, resultLocal);
		}

		[TestMethod]
		public void Age_WhenFutureDateOffByOneDay_ShouldAdjustAgeUpward()
		{
			// Arrange
			DateTime firstDate = new DateTime(2024, 4, 19);
			DateTime secondDate = new DateTime(2024, 4, 18);

			// Act
			int age = firstDate.Age(secondDate);

			// Assert
			Assert.AreEqual(0, age); // Expected because although firstDate > secondDate, the offset is within correction threshold
		}

	}
}