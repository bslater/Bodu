// ---------------------------------------------------------------------------------------------------------------
// <auto-generated />
// ---------------------------------------------------------------------------------------------------------------

using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Bodu.Extensions;
using System.Globalization;

namespace Bodu.Extensions
{
	public partial class DateTimeExtensionsTests
	{

		public static IEnumerable<object[]> NextOccurrenceTestData
		{
			get
			{
				// Format: start, interval, after, expected result

				// Exact match: next occurrence is 'start' itself + interval
				yield return new object[] { new DateTime(2024, 1, 1, 0, 0, 0), TimeSpan.FromDays(1), new DateTime(2024, 1, 2, 0, 0, 0), new DateTime(2024, 1, 2, 0, 0, 0) };
				// Just before interval boundary
				yield return new object[] { new DateTime(2024, 1, 1), TimeSpan.FromDays(1), new DateTime(2024, 1, 1, 23, 59, 59), new DateTime(2024, 1, 2) };
				// Multiple intervals
				yield return new object[] { new DateTime(2024, 1, 1, 0, 0, 0), TimeSpan.FromHours(6), new DateTime(2024, 1, 1, 13, 0, 0), new DateTime(2024, 1, 1, 18, 0, 0) };
				// Crossing days
				yield return new object[] { new DateTime(2024, 12, 31, 22, 0, 0), TimeSpan.FromHours(5), new DateTime(2025, 1, 1, 6, 0, 0), new DateTime(2025, 1, 1, 8, 0, 0) };
				// Large interval
				yield return new object[] { new DateTime(2020, 1, 1), TimeSpan.FromDays(365), new DateTime(2024, 5, 1), new DateTime(2024, 12, 30) };
				// Tiny interval
				yield return new object[] { new DateTime(2024, 1, 1), TimeSpan.FromMilliseconds(1), new DateTime(2024, 1, 1, 0, 0, 0, 1), new DateTime(2024, 1, 1, 0, 0, 0, 1) };
				// after equals start (should return start itself as next occurrence)
				yield return new object[] { new DateTime(2024, 1, 1), TimeSpan.FromDays(1), new DateTime(2024, 1, 1), new DateTime(2024, 1, 1) };
				// after is before start (always return start)
				yield return new object[] { new DateTime(2024, 1, 2), TimeSpan.FromDays(1), new DateTime(2024, 1, 1), new DateTime(2024, 1, 2) };
			}
		}

		/// <summary>
		/// Verifies that <see cref="DateTimeExtensions.NextOccurrence(DateTime, TimeSpan, DateTime)"/> returns the expected result
		/// for valid combinations of start, interval, and after values.
		/// </summary>
		[DataTestMethod]
		[DynamicData(nameof(NextOccurrenceTestData), typeof(DateTimeExtensionsTests))]
		public void NextOccurrence_WhenValid_ShouldReturnExpected(DateTime start, TimeSpan interval, DateTime after, DateTime? expected)
		{
			DateTime result = start.NextOccurrence(interval, after);

			Assert.AreEqual(expected, result, $"Expected next occurrence from {start} every {interval} after {after} to be {expected}");
		}

		[DataTestMethod]
		[DataRow(0)]
		[DataRow(-1)]
		public void NextOccurrence_WhenInvalidTimeSpan_ShouldThrowArgumentOutOfRangeException(long  ticks)
		{
			var start = new DateTime(2024, 4, 4);
			var after=new DateTime(2024, 6, 4);
			var interval =new  TimeSpan(ticks);

			Assert.ThrowsException<ArgumentOutOfRangeException>(() =>
			{
				_ = start.NextOccurrence(interval, after);
			});

		}
	}
}